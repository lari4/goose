# Goose Agent Pipelines Documentation

Этот документ описывает все возможные схемы работы (пайплайны) AI агента Goose, показывая какие промпты используются, в какой последовательности, и какие данные передаются между этапами.

---

## 1. Основной Пайплайн Взаимодействия с Пользователем (Main User Interaction Pipeline)

Это основной рабочий цикл агента при обработке запросов пользователя.

### Схема потока данных

```
┌─────────────────────────────────────────────────────────────────────┐
│                         НАЧАЛО ВЗАИМОДЕЙСТВИЯ                        │
└──────────────────────────────┬──────────────────────────────────────┘
                               │
                               ▼
┌─────────────────────────────────────────────────────────────────────┐
│  1. СБОРКА СИСТЕМНОГО ПРОМПТА (Prompt Manager)                      │
│  ─────────────────────────────────────────────────────────────────  │
│  • Выбор базового промпта:                                          │
│    - system.md (стандартный режим)                                  │
│    - system_gpt_4.1.md (расширенный режим)                          │
│  • Добавление frontend instructions:                                │
│    - desktop_prompt.md (если Desktop)                               │
│    - cli_prompt.rs (если CLI)                                       │
│  • Добавление промптов активных расширений:                         │
│    - Extension Manager, Todo, ChatRecall и т.д.                     │
│    - Memory, Tutorial, ComputerController и т.д.                    │
│  • Добавление tool_selection_strategy (если динамический выбор)     │
│  • Применение system_prompt_override (если есть)                    │
│  • Применение system_prompt_extras (если есть)                      │
│                                                                      │
│  ВЫХОД: Финальный системный промпт                                  │
└──────────────────────────────┬──────────────────────────────────────┘
                               │
                               ▼
┌─────────────────────────────────────────────────────────────────────┐
│  2. ПРОВЕРКА КОНТЕКСТА (Context Check)                              │
│  ─────────────────────────────────────────────────────────────────  │
│  • Проверка: достигнут ли лимит контекста?                          │
│  • Если ДА → переход к Context Summarization Pipeline (раздел 2)   │
│  • Если НЕТ → продолжение                                           │
└──────────────────────────────┬──────────────────────────────────────┘
                               │
                               ▼
┌─────────────────────────────────────────────────────────────────────┐
│  3. ПОДГОТОВКА СООБЩЕНИЙ                                            │
│  ─────────────────────────────────────────────────────────────────  │
│  • История разговора (Conversation)                                 │
│  • Текущее сообщение пользователя                                   │
│  • Метаданные видимости (agent_visible, user_visible)              │
└──────────────────────────────┬──────────────────────────────────────┘
                               │
                               ▼
┌─────────────────────────────────────────────────────────────────────┐
│  4. ДИНАМИЧЕСКИЙ ВЫБОР ИНСТРУМЕНТОВ (опционально)                   │
│  ─────────────────────────────────────────────────────────────────  │
│  • Если включен dynamic tool selection:                             │
│    → переход к Tool Selection Pipeline (раздел 5)                   │
│  • Иначе: использовать все доступные инструменты                    │
└──────────────────────────────┬──────────────────────────────────────┘
                               │
                               ▼
┌─────────────────────────────────────────────────────────────────────┐
│  5. LLM ВЫЗОВ (Provider Complete)                                   │
│  ─────────────────────────────────────────────────────────────────  │
│  ВХОД:                                                               │
│  • system_prompt (из шага 1)                                        │
│  • conversation (из шага 3)                                         │
│  • tools (список доступных инструментов)                            │
│                                                                      │
│  ВЫХОД:                                                              │
│  • Response (сообщение ассистента)                                  │
│  • Tool requests (опционально)                                      │
│  • Provider usage (статистика)                                      │
└──────────────────────────────┬──────────────────────────────────────┘
                               │
                               ▼
                    ┌──────────┴──────────┐
                    │  Tool requests?     │
                    └──────────┬──────────┘
                         ДА    │    НЕТ
                    ┌──────────┴──────────┐
                    │                     │
                    ▼                     ▼
┌─────────────────────────────────┐  ┌──────────────────────────┐
│  6a. ПРОВЕРКА РАЗРЕШЕНИЙ        │  │  6b. ВОЗВРАТ ОТВЕТА      │
│  ───────────────────────────     │  │  ───────────────────     │
│  • Анализ tool requests          │  │  • Отобразить ответ      │
│  • Определение read-only         │  │    пользователю          │
│  • Permission Pipeline (раздел 6)│  │  • Сохранить в историю   │
│  • Получение approval            │  └──────────────────────────┘
└──────────────┬──────────────────┘                │
               │                                   │
               ▼                                   │
┌─────────────────────────────────┐               │
│  7. ВЫПОЛНЕНИЕ ИНСТРУМЕНТОВ     │               │
│  ───────────────────────────     │               │
│  • Выполнение одобренных tools   │               │
│  • Сбор результатов              │               │
│  • Обработка ошибок              │               │
└──────────────┬──────────────────┘               │
               │                                   │
               ▼                                   │
┌─────────────────────────────────┐               │
│  8. РЕКУРСИВНЫЙ ВЫЗОВ LLM       │               │
│  ───────────────────────────     │               │
│  • Добавить tool results         │               │
│    к conversation                │               │
│  • Вернуться к шагу 5            │               │
│  • Повторять пока нет final      │               │
│    ответа или лимита ходов       │               │
└──────────────┬──────────────────┘               │
               │                                   │
               └───────────────────────────────────┘
                               │
                               ▼
┌─────────────────────────────────────────────────────────────────────┐
│  9. ЗАВЕРШЕНИЕ                                                       │
│  ─────────────────────────────────────────────────────────────────  │
│  • Сохранение сессии                                                │
│  • Обновление статистики                                            │
│  • Возврат контроля пользователю                                    │
└─────────────────────────────────────────────────────────────────────┘
```

### Переменные и данные между этапами

**Шаг 1 → Шаг 5:**
- `system_prompt` (String): Полностью собранный системный промпт
- `extensions` (Vec): Список активных расширений с их инструкциями

**Шаг 3 → Шаг 5:**
- `conversation` (Conversation): История сообщений
- `messages` (Vec<Message>): Массив сообщений User/Assistant/Tool

**Шаг 5 → Шаг 6:**
- `response` (Message): Ответ LLM
- `tool_requests` (Vec<ToolRequest>): Запросы на выполнение инструментов
- `provider_usage` (ProviderUsage): Статистика использования токенов

**Шаг 6a → Шаг 7:**
- `approved_tools` (Vec<ToolRequest>): Одобренные инструменты
- `approval_status` (HashMap): Статус разрешения для каждого инструмента

**Шаг 7 → Шаг 8:**
- `tool_results` (Vec<ToolResult>): Результаты выполнения инструментов
- `errors` (Vec<Error>): Ошибки выполнения (если есть)

### Примечания

- Цикл шагов 5-8 может повторяться несколько раз (multi-turn conversation)
- На каждой итерации контекст растет (добавляются tool requests и results)
- При достижении лимита контекста запускается Context Summarization Pipeline
- При достижении max_turns взаимодействие завершается

---

## 2. Пайплайн Суммаризации Контекста (Context Summarization Pipeline)

Автоматически срабатывает когда размер контекста приближается к лимиту модели.

### Схема потока данных

```
┌─────────────────────────────────────────────────────────────────────┐
│  ТРИГГЕР: Размер контекста >= порог                                  │
└──────────────────────────────┬──────────────────────────────────────┘
                               │
                               ▼
┌─────────────────────────────────────────────────────────────────────┐
│  1. ПОДГОТОВКА СООБЩЕНИЙ ДЛЯ СУММАРИЗАЦИИ                            │
│  ─────────────────────────────────────────────────────────────────  │
│  • Извлечение всех сообщений до последнего user message (если есть) │
│  • Сохранение последнего user message отдельно (опционально)        │
│                                                                      │
│  ВХОД: conversation (полная история)                                │
│  ВЫХОД: messages_to_compact (сообщения для сжатия)                  │
└──────────────────────────────┬──────────────────────────────────────┘
                               │
                               ▼
┌─────────────────────────────────────────────────────────────────────┐
│  2. ПОСТРОЕНИЕ ПРОМПТА ДЛЯ СУММАРИЗАЦИИ                             │
│  ─────────────────────────────────────────────────────────────────  │
│  • Загрузка: summarize_oneshot.md                                   │
│  • Рендеринг с переменными:                                         │
│    - {{messages}}: messages_to_compact в текстовом формате          │
│                                                                      │
│  ВЫХОД: system_prompt для суммаризации                              │
└──────────────────────────────┬──────────────────────────────────────┘
                               │
                               ▼
┌─────────────────────────────────────────────────────────────────────┐
│  3. СОЗДАНИЕ USER ЗАПРОСА НА СУММАРИЗАЦИЮ                           │
│  ─────────────────────────────────────────────────────────────────  │
│  Message::user().with_text(                                         │
│    "Please summarize the conversation history                       │
│     provided in the system prompt."                                 │
│  )                                                                   │
│                                                                      │
│  ВЫХОД: summarization_request (массив с 1 сообщением)               │
└──────────────────────────────┬──────────────────────────────────────┘
                               │
                               ▼
┌─────────────────────────────────────────────────────────────────────┐
│  4. LLM ВЫЗОВ (Fast Model)                                          │
│  ─────────────────────────────────────────────────────────────────  │
│  provider.complete_fast(                                            │
│    &system_prompt,                                                  │
│    &summarization_request,                                          │
│    &[]  // no tools                                                 │
│  )                                                                   │
│                                                                      │
│  ВЫХОД:                                                              │
│  • summary_message (Message с подробной суммаризацией)              │
│  • provider_usage (статистика)                                      │
└──────────────────────────────┬──────────────────────────────────────┘
                               │
                               ▼
┌─────────────────────────────────────────────────────────────────────┐
│  5. ОБРАБОТКА РЕЗУЛЬТАТА                                            │
│  ─────────────────────────────────────────────────────────────────  │
│  • Изменить role summary_message: User (было Assistant)            │
│  • Добавить метаданные:                                             │
│    - agent_visible = true                                           │
│    - user_visible = false                                           │
└──────────────────────────────┬──────────────────────────────────────┘
                               │
                               ▼
┌─────────────────────────────────────────────────────────────────────┐
│  6. ПОСТРОЕНИЕ НОВОГО КОНТЕКСТА                                     │
│  ─────────────────────────────────────────────────────────────────  │
│  final_messages = [                                                 │
│    // Оригинальные сообщения с измененной видимостью:               │
│    ...original_messages (agent_visible=false, user_visible=true)    │
│                                                                      │
│    // Summary message (только для агента):                          │
│    summary_message (agent_visible=true, user_visible=false)         │
│                                                                      │
│    // Instruction message (только для агента):                      │
│    Message::assistant().with_text(                                  │
│      "The previous message contains a summary...                    │
│       Do not mention that you read a summary...                     │
│       Just continue the conversation naturally..."                  │
│    ) (agent_visible=true, user_visible=false)                       │
│                                                                      │
│    // Последнее user message (если было сохранено):                 │
│    last_user_message (опционально)                                  │
│  ]                                                                   │
└──────────────────────────────┬──────────────────────────────────────┘
                               │
                               ▼
┌─────────────────────────────────────────────────────────────────────┐
│  7. ВОЗВРАТ В ОСНОВНОЙ ПАЙПЛАЙН                                      │
│  ─────────────────────────────────────────────────────────────────  │
│  • Замена conversation на compacted_conversation                    │
│  • Продолжение основного пайплайна с шага 5 (LLM вызов)             │
└─────────────────────────────────────────────────────────────────────┘
```

### Переменные и данные

**Вход в пайплайн:**
- `conversation` (Conversation): Полная история разговора
- `preserve_last_user_message` (bool): Сохранять ли последнее сообщение пользователя

**Между этапами:**
- `messages_to_compact` (Vec<Message>): Сообщения для сжатия
- `system_prompt` (String): Промпт из summarize_oneshot.md с {{messages}}
- `summary_message` (Message): Результат суммаризации от LLM
- `final_messages` (Vec<Message>): Новая сжатая история

**Выход из пайплайна:**
- `compacted_conversation` (Conversation): Сжатая история разговора
- `summarization_usage` (ProviderUsage): Статистика использования токенов

### Промпты, используемые на каждом этапе

1. **Шаг 2**: `summarize_oneshot.md` - основной промпт суммаризации
2. **Шаг 6**: Встроенный текст инструкции (из `context_mgmt/mod.rs`)

### Примечания

- Используется быстрая модель (complete_fast) для экономии времени
- Суммаризация включает 9 обязательных секций (User Intent, Technical Concepts, Files + Code и т.д.)
- Оригинальные сообщения остаются в истории для пользователя, но невидимы для агента
- Summary видима только агенту, невидима пользователю
- Агент не должен упоминать о суммаризации в ответе пользователю

---

## 3. Пайплайн Планирования (Planning Pipeline)

Используется когда нужно создать детальный план выполнения перед началом работы (опциональный режим).

### Схема потока данных

```
┌─────────────────────────────────────────────────────────────────────┐
│  ТРИГГЕР: Запуск с plan_mode=true                                    │
└──────────────────────────────┬──────────────────────────────────────┘
                               │
                               ▼
┌─────────────────────────────────────────────────────────────────────┐
│  1. ПОСТРОЕНИЕ PLANNER ПРОМПТА                                       │
│  ─────────────────────────────────────────────────────────────────  │
│  • Загрузка: plan.md                                                │
│  • Рендеринг с переменными:                                         │
│    - {{tools}}: Список доступных инструментов с описаниями          │
│                                                                      │
│  ВЫХОД: planner_system_prompt                                       │
└──────────────────────────────┬──────────────────────────────────────┘
                               │
                               ▼
┌─────────────────────────────────────────────────────────────────────┐
│  2. LLM ВЫЗОВ ПЛАНИРОВЩИКА                                          │
│  ─────────────────────────────────────────────────────────────────  │
│  provider.complete(                                                 │
│    &planner_system_prompt,                                          │
│    &user_messages,  // Исходные сообщения пользователя             │
│    &[]              // no tools                                     │
│  )                                                                   │
│                                                                      │
│  ВЫХОД:                                                              │
│  • plan_or_questions (Message): План ИЛИ уточняющие вопросы        │
│  • provider_usage                                                   │
└──────────────────────────────┬──────────────────────────────────────┘
                               │
                               ▼
                    ┌──────────┴──────────┐
                    │   Вопросы или       │
                    │      План?          │
                    └──────────┬──────────┘
                    ВОПРОСЫ    │    ПЛАН
                    ┌──────────┴──────────┐
                    │                     │
                    ▼                     ▼
┌─────────────────────────────────┐  ┌──────────────────────────────┐
│  3a. ВОПРОСЫ К ПОЛЬЗОВАТЕЛЮ     │  │  3b. ВЫПОЛНЕНИЕ ПЛАНА        │
│  ───────────────────────────     │  │  ──────────────────────      │
│  • Отобразить вопросы            │  │  • План → user message       │
│  • Ждать ответа                  │  │  • Очистить историю          │
│  • Вернуться к шагу 2            │  │  • Запустить executor        │
│    с дополнительным контекстом   │  │    (Main Pipeline)           │
└─────────────────────────────────┘  │  • Plan как первое           │
                                      │    сообщение пользователя    │
                                      └──────────────────────────────┘
```

### Переменные и данные

**Вход:**
- `user_messages` (Vec<Message>): Сообщения пользователя
- `available_tools` (Vec<Tool>): Доступные инструменты

**Между этапами:**
- `planner_system_prompt` (String): Промпт из plan.md
- `plan_or_questions` (Message): Результат от planner AI

**Выход (если план):**
- `plan_message` (Message): Детальный пошаговый план
- Переход к Main Pipeline с планом как user message

**Выход (если вопросы):**
- `questions_message` (Message): Уточняющие вопросы
- Ожидание ответа пользователя → повторный вызов планировщика

### Промпты

- **Шаг 1**: `plan.md` - промпт планировщика

### Ключевые особенности

- **Одноразовый ответ**: Планировщик отвечает только один раз
- **Два режима вывода**:
  - План → появляется как user message в новом контексте для executor
  - Вопросы → появляются как assistant message в текущем контексте
- **Проверка ясности**: Планировщик проверяет достаточно ли информации
- **Зависимости**: План включает указание зависимостей между шагами
- **Условная логика**: План может включать ветвления (if-then-else)

---

## 4. Пайплайн Выполнения Субагентов (Subagent Execution Pipeline)

Создание и выполнение специализированных субагентов для конкретных задач.

### Схема потока данных

```
┌─────────────────────────────────────────────────────────────────────┐
│  ТРИГГЕР: Вызов dynamic_task__create_task или встроенных субагентов │
└──────────────────────────────┬──────────────────────────────────────┘
                               │
                               ▼
┌─────────────────────────────────────────────────────────────────────┐
│  1. СОЗДАНИЕ СУБАГЕНТА                                               │
│  • subagent_system.md + task_instructions                           │
│  • max_turns, timeout, available_tools                              │
└──────────────────────────────┬──────────────────────────────────────┘
                               │
                               ▼
┌─────────────────────────────────────────────────────────────────────┐
│  2. ВЫПОЛНЕНИЕ (Main Pipeline для субагента)                        │
│  • Ограничение по max_turns                                         │
│  • Возврат результата или таймаут                                   │
└──────────────────────────────┬──────────────────────────────────────┘
                               │
                               ▼
┌─────────────────────────────────────────────────────────────────────┐
│  3. ВОЗВРАТ РЕЗУЛЬТАТА                                               │
│  • Результат → основному агенту как tool_result                     │
└─────────────────────────────────────────────────────────────────────┘
```

### Режимы выполнения

- **Parallel**: Несколько субагентов выполняются одновременно
- **Sequential**: Субагенты выполняются последовательно, результат предыдущего → следующему

### Промпты

- `subagent_system.md` с переменными: {{task_instructions}}, {{max_turns}}, {{tool_count}}, {{available_tools}}

---

## 5. Пайплайн Динамического Выбора Инструментов (Tool Selection Pipeline)

Интеллектуальный выбор релевантных инструментов для экономии контекста.

### Схема потока данных

```
┌─────────────────────────────────────────────────────────────────────┐
│  ТРИГГЕР: Вызов llm_search tool                                      │
└──────────────────────────────┬──────────────────────────────────────┘
                               │
                               ▼
┌─────────────────────────────────────────────────────────────────────┐
│  1. ПОСТРОЕНИЕ ПРОМПТА СЕЛЕКТОРА                                     │
│  • router_tool_selector.md                                          │
│  • {{tools}}: Все доступные инструменты                             │
│  • {{query}}: Запрос пользователя с ключевыми словами              │
└──────────────────────────────┬──────────────────────────────────────┘
                               │
                               ▼
┌─────────────────────────────────────────────────────────────────────┐
│  2. LLM ВЫЗОВ СЕЛЕКТОРА                                              │
│  • Возвращает релевантные инструменты                               │
└──────────────────────────────┬──────────────────────────────────────┘
                               │
                               ▼
┌─────────────────────────────────────────────────────────────────────┐
│  3. АКТИВАЦИЯ ИНСТРУМЕНТОВ                                           │
│  • Добавление выбранных tools в контекст                            │
│  • Возврат в Main Pipeline                                          │
└─────────────────────────────────────────────────────────────────────┘
```

### Промпты

1. `router_tool_selector.md` - промпт для выбора инструментов
2. `llm_search_tool_prompt()` - инструкции для основного агента (из router_tools.rs)

---

## 6. Пайплайн Проверки Разрешений (Permission Check Pipeline)

Анализ операций на предмет read-only для автоматического одобрения.

### Схема потока данных

```
┌─────────────────────────────────────────────────────────────────────┐
│  ТРИГГЕР: Tool requests от основного агента                         │
└──────────────────────────────┬──────────────────────────────────────┘
                               │
                               ▼
┌─────────────────────────────────────────────────────────────────────┐
│  1. ПОСТРОЕНИЕ ПРОМПТА СУДЬИ                                         │
│  • permission_judge.md                                              │
│  • Список tool_names для анализа                                    │
└──────────────────────────────┬──────────────────────────────────────┘
                               │
                               ▼
┌─────────────────────────────────────────────────────────────────────┐
│  2. LLM ВЫЗОВ (fast model)                                          │
│  • platform__tool_by_tool_permission tool                           │
│  • Возврат: {read_only_tools: [tool_names]}                         │
└──────────────────────────────┬──────────────────────────────────────┘
                               │
                               ▼
┌─────────────────────────────────────────────────────────────────────┐
│  3. ОБРАБОТКА РЕЗУЛЬТАТА                                            │
│  • Read-only tools → автоматическое одобрение                       │
│  • Write tools → запрос подтверждения у пользователя                │
└─────────────────────────────────────────────────────────────────────┘
```

### Промпты

1. `permission_judge.md` - системный промпт судьи
2. Встроенный промпт инструмента `platform__tool_by_tool_permission` (permission_judge.rs)

---

## 7. Пайплайн Работы с Памятью (Memory Pipeline)

Сохранение и извлечение долгосрочной памяти между сессиями.

### Схема сохранения

```
┌─────────────────────────────────────────────────────────────────────┐
│  ТРИГГЕР: Ключевые слова "remember", "save", "memory" и т.д.        │
└──────────────────────────────┬──────────────────────────────────────┘
                               │
                               ▼
┌─────────────────────────────────────────────────────────────────────┐
│  1. ИДЕНТИФИКАЦИЯ ВАЖНОЙ ИНФОРМАЦИИ                                 │
│  • Memory extension instructions определяют триггеры                │
│  • User-specific data, project configs, workflows                   │
└──────────────────────────────┬──────────────────────────────────────┘
                               │
                               ▼
┌─────────────────────────────────────────────────────────────────────┐
│  2. ПРОТОКОЛ ВЗАИМОДЕЙСТВИЯ                                         │
│  • Спросить: сохранить ли информацию?                               │
│  • Предложить категорию (personal, development и т.д.)              │
│  • Уточнить теги                                                    │
│  • Уточнить scope: local (.goose/memory) vs global (~/.config)     │
└──────────────────────────────┬──────────────────────────────────────┘
                               │
                               ▼
┌─────────────────────────────────────────────────────────────────────┐
│  3. СОХРАНЕНИЕ                                                       │
│  • remember_memory(category, data, tags, is_global)                 │
│  • Запись в файл {category}.txt                                    │
└──────────────────────────────┬──────────────────────────────────────┘
                               │
                               ▼
┌─────────────────────────────────────────────────────────────────────┐
│  4. ОБНОВЛЕНИЕ СИСТЕМНОГО ПРОМПТА                                    │
│  • Добавление сохраненной памяти в instructions                     │
│  • Доступна в последующих сессиях                                   │
└─────────────────────────────────────────────────────────────────────┘
```

### Схема извлечения

```
┌─────────────────────────────────────────────────────────────────────┐
│  1. ЗАПРОС ИНФОРМАЦИИ                                                │
│  • retrieve_memories(category, is_global)                           │
│  • Опционально: фильтр по тегам                                     │
└──────────────────────────────┬──────────────────────────────────────┘
                               │
                               ▼
┌─────────────────────────────────────────────────────────────────────┐
│  2. ЧТЕНИЕ ИЗ ФАЙЛОВ                                                 │
│  • Парсинг {category}.txt                                           │
│  • Поиск по content или tags                                        │
└──────────────────────────────┬──────────────────────────────────────┘
                               │
                               ▼
┌─────────────────────────────────────────────────────────────────────┐
│  3. ВОЗВРАТ РЕЗУЛЬТАТА                                               │
│  • HashMap<Category, Vec<Memory>>                                   │
│  • Представление пользователю                                       │
└─────────────────────────────────────────────────────────────────────┘
```

### Промпты

- Инструкции Memory extension (memory/mod.rs) - очень подробные, включают протоколы взаимодействия

---

## 8. Пайплайн Выполнения Рецептов (Recipe Execution Pipeline)

Выполнение предопределенных рецептов с финальным выводом.

### Схема потока данных

```
┌─────────────────────────────────────────────────────────────────────┐
│  1. ЗАГРУЗКА РЕЦЕПТА                                                 │
│  • Чтение recipe.yaml                                               │
│  • instructions, json_schema, initial_prompt                        │
└──────────────────────────────┬──────────────────────────────────────┘
                               │
                               ▼
┌─────────────────────────────────────────────────────────────────────┐
│  2. ДОПОЛНЕНИЕ СИСТЕМНОГО ПРОМПТА                                    │
│  • Базовый промпт + recipe instructions                             │
│  • Добавление final_output tool                                     │
└──────────────────────────────┬──────────────────────────────────────┘
                               │
                               ▼
┌─────────────────────────────────────────────────────────────────────┐
│  3. ВЫПОЛНЕНИЕ (Main Pipeline)                                       │
│  • С обязательным вызовом final_output                              │
└──────────────────────────────┬──────────────────────────────────────┘
                               │
                               ▼
┌─────────────────────────────────────────────────────────────────────┐
│  4. ВАЛИДАЦИЯ ФИНАЛЬНОГО ВЫВОДА                                      │
│  • Проверка соответствия json_schema                                │
│  • Если ошибка → сообщение агенту с деталями                        │
└──────────────────────────────┬──────────────────────────────────────┘
                               │
                               ▼
┌─────────────────────────────────────────────────────────────────────┐
│  5. ВОЗВРАТ РЕЗУЛЬТАТА                                               │
│  • Validated JSON output                                            │
└─────────────────────────────────────────────────────────────────────┘
```

### Промпты

1. Инструкции из recipe.yaml
2. `final_output_tool.rs` - промпт инструмента с json_schema
3. Continuation message: "You MUST call the final_output tool NOW..."

---

## 9. Взаимосвязь Пайплайнов

### Основные точки интеграции

```
Main User Interaction Pipeline
    │
    ├──► Context Summarization (при лимите контекста)
    │    └──► возврат в Main Pipeline
    │
    ├──► Tool Selection (при dynamic tool selection)
    │    └──► возврат в Main Pipeline с выбранными tools
    │
    ├──► Permission Check (при tool requests)
    │    └──► возврат в Main Pipeline с approval
    │
    ├──► Subagent Execution (при вызове dynamic_task)
    │    └──► возврат в Main Pipeline с результатом
    │
    └──► Memory Pipeline (при триггерных словах)
         └──► интеграция в системный промпт

Planning Pipeline
    └──► Main Pipeline (с планом как первым сообщением)

Recipe Pipeline
    └──► Main Pipeline (с recipe instructions + final_output tool)
```

### Порядок выполнения промптов в типичной сессии

```
1. Начало сессии:
   system.md (или system_gpt_4.1.md)
   + desktop_prompt.md (если Desktop)
   + cli_prompt.rs (если CLI)
   + extension instructions (Memory, Todo, ChatRecall и т.д.)
   + loaded memories (если есть сохраненные)

2. При plan_mode:
   plan.md → генерация плана

3. Основной цикл:
   Main Pipeline (шаги 1-9)

4. При dynamic tool selection:
   router_tool_selector.md → выбор инструментов

5. При tool requests:
   permission_judge.md → проверка разрешений

6. При создании субагента:
   subagent_system.md + task_instructions

7. При лимите контекста:
   summarize_oneshot.md → суммаризация
   + post-summarization instruction

8. При работе с памятью:
   memory instructions (протокол взаимодействия)

9. При выполнении рецепта:
   recipe instructions + final_output tool
```

---

## Заключение

Система Goose использует сложную иерархию пайплайнов для обработки различных сценариев взаимодействия:

1. **Main Pipeline** - основной рабочий цикл
2. **Context Summarization** - управление размером контекста
3. **Planning** - предварительное планирование задач
4. **Subagent Execution** - делегирование специализированным агентам
5. **Tool Selection** - интеллектуальный выбор инструментов
6. **Permission Check** - контроль безопасности
7. **Memory** - долгосрочная память между сессиями
8. **Recipe** - выполнение предопределенных workflow

Все пайплайны интегрированы через систему промптов (Jinja2 templates) и динамически собираются в зависимости от режима работы, активных расширений и контекста взаимодействия.
